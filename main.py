{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "0c2b5323",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Step One:\n",
      "Write your message (max length 50 words): hello how are you doing?\n",
      "\n",
      "Step Two:\n",
      "Sending the encrypted message to None sandbox...\n",
      "\n",
      "Step Three:\n",
      "New message received in the user's sandbox.\n",
      "\n",
      "Step Four:\n",
      "Sanjeeb, would you like to read the message? (y/n): y\n",
      "Enter your password: +919583495373\n",
      "Password incorrect.\n",
      "\n",
      "Step Five:\n",
      "Enter CDAC's password to view contents: cdachacathron2023\n",
      "Password incorrect. QKD is not generated.\n",
      "\n",
      "Step Six:\n",
      "Program terminates.\n"
     ]
    }
   ],
   "source": [
    "import time\n",
    "from cryptography.hazmat.primitives import hashes\n",
    "from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC\n",
    "from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC\n",
    "from cryptography.hazmat.backends import default_backend\n",
    "from cryptography.hazmat.primitives import serialization\n",
    "from cryptography.hazmat.primitives.asymmetric import rsa\n",
    "from cryptography.hazmat.primitives import padding\n",
    "from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes\n",
    "\n",
    "class QuantumBB84Protocol:\n",
    "    def generate_quantum_keys(self):\n",
    "        # Implement the BB84 protocol to generate quantum keys\n",
    "        pass\n",
    "\n",
    "class UserCommunication:\n",
    "    def __init__(self):\n",
    "        self.messages = []\n",
    "\n",
    "    def write_message(self):\n",
    "        message = input(\"Write your message (max length 50 words): \")\n",
    "        self.messages.append(message)\n",
    "\n",
    "    def encrypt_message(self, message, key):\n",
    "        # Implement AES encryption of the message using the key\n",
    "        pass\n",
    "\n",
    "    def select_recipient(self):\n",
    "        # Display the list of users and ask for recipient's sandbox\n",
    "        pass\n",
    "\n",
    "class Main:\n",
    "    def __init__(self):\n",
    "        self.users = {\n",
    "            \"Sanjeeb\": {\"password\": \"+919583495373\", \"mobile_number\": \"+919583495373\"},\n",
    "            \"Vishal\": {\"password\": \"+919547550869\", \"mobile_number\": \"+919547550869\"},\n",
    "            \"Rashmi Kant\": {\"password\": \"+917504096957\", \"mobile_number\": \"+917504096957\"},\n",
    "            \"CDAC\": {\"password\": \"cdachacathron2023\", \"mobile_number\": None}\n",
    "        }\n",
    "\n",
    "        self.bb84_protocol = QuantumBB84Protocol()\n",
    "        self.user_communication = UserCommunication()\n",
    "\n",
    "    def mask_password(self, password):\n",
    "        time.sleep(1)\n",
    "        return \"*\" * len(password)\n",
    "\n",
    "    def run(self):\n",
    "        print(\"Step One:\")\n",
    "        self.user_communication.write_message()\n",
    "\n",
    "        print(\"\\nStep Two:\")\n",
    "        message = self.user_communication.messages[-1]\n",
    "        key = b'some_secret_key'  # Replace this with a proper key generation method\n",
    "        encrypted_message = self.user_communication.encrypt_message(message, key)\n",
    "        recipient = self.user_communication.select_recipient()\n",
    "        print(f\"Sending the encrypted message to {recipient} sandbox...\")\n",
    "\n",
    "        print(\"\\nStep Three:\")\n",
    "        # Display a message that a new message is received by the user\n",
    "        print(\"New message received in the user's sandbox.\")\n",
    "\n",
    "        print(\"\\nStep Four:\")\n",
    "        recipient_name = \"Sanjeeb\"  # Replace this with the actual recipient's name\n",
    "        read_message_choice = input(f\"{recipient_name}, would you like to read the message? (y/n): \")\n",
    "        if read_message_choice.lower() == \"y\":\n",
    "            password = input(\"Enter your password: \")\n",
    "            masked_password = self.mask_password(password)\n",
    "            if masked_password == self.users[recipient_name][\"password\"]:\n",
    "                print(\"Message decrypted:\")\n",
    "                # Implement decryption of the message using the key\n",
    "                pass\n",
    "            else:\n",
    "                print(\"Password incorrect.\")\n",
    "        else:\n",
    "            print(\"Press F11 to display contents of the CDAC after password verification.\")\n",
    "\n",
    "        print(\"\\nStep Five:\")\n",
    "        password_cdac = input(\"Enter CDAC's password to view contents: \")\n",
    "        masked_password_cdac = self.mask_password(password_cdac)\n",
    "        if masked_password_cdac == self.users[\"CDAC\"][\"password\"]:\n",
    "            # Display public key used, private key used, and Quantum key used (if bb84 protocol is invoked)\n",
    "            # The keys should have been generated earlier in the process\n",
    "            pass\n",
    "        else:\n",
    "            print(\"Password incorrect. QKD is not generated.\")\n",
    "\n",
    "        print(\"\\nStep Six:\")\n",
    "        print(\"Program terminates.\")\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    main = Main()\n",
    "    main.run()\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "7e4ed10d",
   "metadata": {},
   "outputs": [],
   "source": [
    "import time\n",
    "from cryptography.hazmat.primitives import hashes\n",
    "from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC\n",
    "from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC\n",
    "from cryptography.hazmat.backends import default_backend\n",
    "from cryptography.hazmat.primitives import serialization\n",
    "from cryptography.hazmat.primitives.asymmetric import rsa\n",
    "from cryptography.hazmat.primitives import padding\n",
    "from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes\n",
    "\n",
    "class QuantumBB84Protocol:\n",
    "    def generate_quantum_keys(self):\n",
    "        # Implement the BB84 protocol to generate quantum keys\n",
    "        pass\n",
    "\n",
    "class UserCommunication:\n",
    "    def __init__(self):\n",
    "        self.messages = []\n",
    "\n",
    "    def write_message(self):\n",
    "        message = input(\"Write your message (max length 50 words): \")\n",
    "        self.messages.append(message)\n",
    "\n",
    "    def encrypt_message(self, message, key):\n",
    "        # Implement AES encryption of the message using the key\n",
    "        pass\n",
    "\n",
    "    def select_recipient(self, users):\n",
    "        # Display the list of users and ask for recipient's sandbox\n",
    "        print(\"Select the recipient from the following users:\")\n",
    "        for i, user in enumerate(users, start=1):\n",
    "            print(f\"{i}. {user}\")\n",
    "        recipient_choice = int(input(\"Enter the number corresponding to the recipient: \"))\n",
    "        recipient = users[recipient_choice - 1]\n",
    "        return recipient\n",
    "\n",
    "class Main:\n",
    "    def __init__(self):\n",
    "        self.users = {\n",
    "            \"Sanjeeb\": {\"password\": \"+919583495373\", \"mobile_number\": \"+919583495373\"},\n",
    "            \"Vishal\": {\"password\": \"+919547550869\", \"mobile_number\": \"+919547550869\"},\n",
    "            \"Rashmi Kant\": {\"password\": \"+917504096957\", \"mobile_number\": \"+917504096957\"},\n",
    "            \"CDAC\": {\"password\": \"cdachacathron2023\", \"mobile_number\": None}\n",
    "        }\n",
    "\n",
    "        self.bb84_protocol = QuantumBB84Protocol()\n",
    "        self.user_communication = UserCommunication()\n",
    "\n",
    "    def mask_password(self, password):\n",
    "        time.sleep(1)\n",
    "        return \"*\" * len(password)\n",
    "\n",
    "    def run(self):\n",
    "        self.user_communication.write_message()\n",
    "\n",
    "        message = self.user_communication.messages[-1]\n",
    "        key = b'some_secret_key'  # Replace this with a proper key generation method\n",
    "        encrypted_message = self.user_communication.encrypt_message(message, key)\n",
    "\n",
    "        users_list = list(self.users.keys())\n",
    "        recipient = self.user_communication.select_recipient(users_list)\n",
    "        print(f\"Sending the encrypted message to {recipient} sandbox...\")\n",
    "\n",
    "        print(f\"\\nNew message received in {recipient}'s sandbox.\")\n",
    "\n",
    "        recipient_name = recipient\n",
    "        read_message_choice = input(f\"{recipient_name}, would you like to read the message? (y/n): \")\n",
    "        if read_message_choice.lower() == \"y\":\n",
    "            password = input(\"Enter your password: \")\n",
    "            masked_password = self.mask_password(password)\n",
    "            if masked_password == self.users[recipient_name][\"password\"]:\n",
    "                print(\"Message decrypted:\")\n",
    "                # Implement decryption of the message using the key\n",
    "                pass\n",
    "            else:\n",
    "                print(\"Password incorrect.\")\n",
    "        else:\n",
    "            print(f\"{recipient_name} chose not to read the message.\")\n",
    "\n",
    "        password_cdac = input(\"Enter CDAC's password to view contents: \")\n",
    "        masked_password_cdac = self.mask_password(password_cdac)\n",
    "        if masked_password_cdac == self.users[\"CDAC\"][\"password\"]:\n",
    "            # Display public key used, private key used, and Quantum key used (if bb84 protocol is invoked)\n",
    "            # The keys should have been generated earlier in the process\n",
    "            pass\n",
    "        else:\n",
    "            print(\"Password incorrect. QKD is not generated.\")\n",
    "\n",
    "        f11_pressed = input(\"Press F11 to terminate the program: \")\n",
    "        if f11_pressed.lower() == \"f11\":\n",
    "            print(\"Program terminates.\")\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    main = Main()\n",
    "    main.run()\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "2340270b",
   "metadata": {},
   "outputs": [],
   "source": [
    "import time\n",
    "from cryptography.hazmat.primitives import hashes\n",
    "from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC\n",
    "from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC\n",
    "from cryptography.hazmat.backends import default_backend\n",
    "from cryptography.hazmat.primitives import serialization\n",
    "from cryptography.hazmat.primitives.asymmetric import rsa\n",
    "from cryptography.hazmat.primitives import padding\n",
    "from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes\n",
    "\n",
    "class QuantumBB84Protocol:\n",
    "    def generate_quantum_keys(self):\n",
    "        # Implement the BB84 protocol to generate quantum keys\n",
    "        pass\n",
    "\n",
    "class UserCommunication:\n",
    "    def __init__(self):\n",
    "        self.messages = []\n",
    "\n",
    "    def write_message(self):\n",
    "        message = input(\"Write your message (max length 50 words): \")\n",
    "        self.messages.append(message)\n",
    "\n",
    "    def encrypt_message(self, message, key):\n",
    "        # Implement AES encryption of the message using the key\n",
    "        pass\n",
    "\n",
    "    def select_recipient(self, users):\n",
    "        # Display the list of users and ask for recipient's sandbox\n",
    "        print(\"Select the recipient from the following users:\")\n",
    "        for i, user in enumerate(users, start=1):\n",
    "            print(f\"{i}. {user}\")\n",
    "        recipient_choice = int(input(\"Enter the number corresponding to the recipient: \"))\n",
    "        recipient = users[recipient_choice - 1]\n",
    "        return recipient\n",
    "\n",
    "class Main:\n",
    "    def __init__(self):\n",
    "        self.users = {\n",
    "            \"Sanjeeb\": {\"password\": \"+919583495373\", \"mobile_number\": \"+919583495373\"},\n",
    "            \"Vishal\": {\"password\": \"+919547550869\", \"mobile_number\": \"+919547550869\"},\n",
    "            \"Rashmi Kant\": {\"password\": \"+917504096957\", \"mobile_number\": \"+917504096957\"},\n",
    "            \"CDAC\": {\"password\": \"cdachacathron2023\", \"mobile_number\": None}\n",
    "        }\n",
    "\n",
    "        self.bb84_protocol = QuantumBB84Protocol()\n",
    "        self.user_communication = UserCommunication()\n",
    "\n",
    "    def mask_password(self, password):\n",
    "        time.sleep(1)\n",
    "        return \"*\" * len(password)\n",
    "\n",
    "    def run(self):\n",
    "        self.user_communication.write_message()\n",
    "\n",
    "        message = self.user_communication.messages[-1]\n",
    "        key = b'some_secret_key'  # Replace this with a proper key generation method\n",
    "        encrypted_message = self.user_communication.encrypt_message(message, key)\n",
    "\n",
    "        users_list = list(self.users.keys())\n",
    "        recipient = self.user_communication.select_recipient(users_list)\n",
    "        print(f\"Sending the encrypted message to {recipient} sandbox...\")\n",
    "\n",
    "        print(f\"\\nNew message received in {recipient}'s sandbox.\")\n",
    "\n",
    "        recipient_name = recipient\n",
    "        read_message_choice = input(f\"{recipient_name}, would you like to read the message? (y/n): \")\n",
    "        if read_message_choice.lower() == \"y\":\n",
    "            password = input(\"Enter your password: \")\n",
    "            masked_password = self.mask_password(password)\n",
    "            if masked_password == self.users[recipient_name][\"password\"]:\n",
    "                print(\"Message decrypted:\")\n",
    "                # Implement decryption of the message using the key\n",
    "                pass\n",
    "            else:\n",
    "                print(\"Password incorrect.\")\n",
    "        else:\n",
    "            print(f\"{recipient_name} chose not to read the message.\")\n",
    "\n",
    "        password_cdac = input(\"Enter CDAC's password to view contents: \")\n",
    "        masked_password_cdac = self.mask_password(password_cdac)\n",
    "        if masked_password_cdac == self.users[\"CDAC\"][\"password\"]:\n",
    "            # Display public key used, private key used, and Quantum key used (if bb84 protocol is invoked)\n",
    "            # The keys should have been generated earlier in the process\n",
    "            pass\n",
    "        else:\n",
    "            print(\"Password incorrect. QKD is not generated.\")\n",
    "\n",
    "        f11_pressed = input(\"Press F11 to terminate the program: \")\n",
    "        if f11_pressed.lower() == \"f11\":\n",
    "            print(\"Program terminates.\")\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    main = Main()\n",
    "    main.run()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "317704df",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Write your message (max length 50 words): hello how are you doing?\n",
      "Select the recipient from the following users:\n",
      "1. Sanjeeb\n",
      "2. Vishal\n",
      "3. Rashmi Kant\n",
      "4. CDAC\n",
      "Enter the number corresponding to the recipient: 3\n",
      "Sending the encrypted message to Rashmi Kant sandbox...\n",
      "\n",
      "New message received in Rashmi Kant's sandbox.\n",
      "Rashmi Kant, would you like to read the message? (y/n): y\n",
      "Enter your password: “+917504096957”\n",
      "Password incorrect.\n",
      "Enter CDAC's password to view contents: cdachacathron2023\n",
      "Password incorrect. QKD is not generated.\n"
     ]
    }
   ],
   "source": [
    "import time\n",
    "from cryptography.hazmat.primitives import hashes\n",
    "from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC\n",
    "from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC\n",
    "from cryptography.hazmat.backends import default_backend\n",
    "from cryptography.hazmat.primitives import serialization\n",
    "from cryptography.hazmat.primitives.asymmetric import rsa\n",
    "from cryptography.hazmat.primitives import padding\n",
    "from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes\n",
    "\n",
    "class QuantumBB84Protocol:\n",
    "    def generate_quantum_keys(self):\n",
    "        # Implement the BB84 protocol to generate quantum keys\n",
    "        pass\n",
    "\n",
    "class UserCommunication:\n",
    "    def __init__(self):\n",
    "        self.messages = []\n",
    "\n",
    "    def write_message(self):\n",
    "        message = input(\"Write your message (max length 50 words): \")\n",
    "        self.messages.append(message)\n",
    "\n",
    "    def encrypt_message(self, message, key):\n",
    "        # Implement AES encryption of the message using the key\n",
    "        pass\n",
    "\n",
    "    def select_recipient(self, users):\n",
    "        # Display the list of users and ask for recipient's sandbox\n",
    "        print(\"Select the recipient from the following users:\")\n",
    "        for i, user in enumerate(users, start=1):\n",
    "            print(f\"{i}. {user}\")\n",
    "        recipient_choice = int(input(\"Enter the number corresponding to the recipient: \"))\n",
    "        recipient = users[recipient_choice - 1]\n",
    "        return recipient\n",
    "\n",
    "class Main:\n",
    "    def __init__(self):\n",
    "        self.users = {\n",
    "            \"Sanjeeb\": {\"password\": \"+919583495373\", \"mobile_number\": \"+919583495373\"},\n",
    "            \"Vishal\": {\"password\": \"+919547550869\", \"mobile_number\": \"+919547550869\"},\n",
    "            \"Rashmi Kant\": {\"password\": \"+917504096957\", \"mobile_number\": \"+917504096957\"},\n",
    "            \"CDAC\": {\"password\": \"cdachacathron2023\", \"mobile_number\": None}\n",
    "        }\n",
    "\n",
    "        self.bb84_protocol = QuantumBB84Protocol()\n",
    "        self.user_communication = UserCommunication()\n",
    "\n",
    "    def mask_password(self, password):\n",
    "        time.sleep(1)\n",
    "        return \"*\" * len(password)\n",
    "\n",
    "    def run(self):\n",
    "        self.user_communication.write_message()\n",
    "\n",
    "        message = self.user_communication.messages[-1]\n",
    "        key = b'some_secret_key'  # Replace this with a proper key generation method\n",
    "        encrypted_message = self.user_communication.encrypt_message(message, key)\n",
    "\n",
    "        users_list = list(self.users.keys())\n",
    "        recipient = self.user_communication.select_recipient(users_list)\n",
    "        print(f\"Sending the encrypted message to {recipient} sandbox...\")\n",
    "\n",
    "        print(f\"\\nNew message received in {recipient}'s sandbox.\")\n",
    "\n",
    "        recipient_name = recipient\n",
    "        read_message_choice = input(f\"{recipient_name}, would you like to read the message? (y/n): \")\n",
    "        if read_message_choice.lower() == \"y\":\n",
    "            password = input(\"Enter your password: \")\n",
    "            masked_password = self.mask_password(password)\n",
    "            if masked_password == self.users[recipient_name][\"password\"]:\n",
    "                print(\"Message decrypted:\")\n",
    "                # Implement decryption of the message using the key\n",
    "                pass\n",
    "            else:\n",
    "                print(\"Password incorrect.\")\n",
    "        else:\n",
    "            print(f\"{recipient_name} chose not to read the message.\")\n",
    "\n",
    "        password_cdac = input(\"Enter CDAC's password to view contents: \")\n",
    "        masked_password_cdac = self.mask_password(password_cdac)\n",
    "        if masked_password_cdac == self.users[\"CDAC\"][\"password\"]:\n",
    "            # Display public key used, private key used, and Quantum key used (if bb84 protocol is invoked)\n",
    "            # The keys should have been generated earlier in the process\n",
    "            pass\n",
    "        else:\n",
    "            print(\"Password incorrect. QKD is not generated.\")\n",
    "\n",
    "        f11_pressed = input(\"Press F11 to terminate the program: \")\n",
    "        if f11_pressed.lower() == \"f11\":\n",
    "            print(\"Program terminates.\")\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    main = Main()\n",
    "    main.run()\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "e4371267",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.10.9"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
